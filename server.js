// Этот блок подключает внешние зависимости. Создаем константы (переменные которые после инициализации нельзя изменять),
// и с помощью встроенной в NodeJS функции require (этой функции нет в браузерном JS) получаем из внешних модулей объекты 
// с необходимым нам функционалом. Потом на этих объектах мы можем запускать методы, которые оживят наш сервер.
// Почти все эти модули являются строенными в NodeJS, кроме mime, который находится в папке node_modules,
// устанавливается он через команду npm install, а какую версию устанавливать указывается в package.json
// const и let это всего-лишь способы объявления констант и переменных
const zlib = require('zlib'), // Модуль для сжатия данных и создания сжатых потоков данных
      http = require('http'), // Модуль для работы с http протоколом (создание сервера, обработка запросов)
      fs = require('fs'),     // Модуль для работы с файловой системой
      mime = require('mime'), // Сторонний модуль для определения mime типа файла по его расширению
      path = require('path'), // Модуль для работы с путями для файлов и директорий
      url = require('url'),   // Модуль для работы с URL и его парсинга
      portastic = require('portastic');

const EventEmitter = require('events');

// Объявляем базовую директорию, где будут находиться файлы, передаваемые с сервера в браузер клиента. 
// Также указываем порт, на котором будет работать наш сервер. Это всё значения по умолчанию
const baseDefault = './public',
      portDefault = 3001;
      
// Проверяем является ли текущий файл запущенным в Node
if (__filename === process.argv[1]) {
  let base, port;
  // Код ниже считывает параметры запуска скрипта из командной строки. Например: 
  // node server.js --base public --port 3005. 
  // Данная команда запускает сервер в папке public на порту 3005
  // process это глобальный объект, который предоставляет инструменты по работе с текущим Node процессом
  // process.argv содержит в себе не только параметры вызова, но и команду, и название скрипта, идущими
  // первыми двумя элементами process.argv. Полный вид массива process.argv для нашего примера вызова:
  // ['node', 'server.js', '--base', 'public', '--port', '3005']
  // С помощью функции slice(2) мы создаем подмассив без первых двух элементов и перебираем его с помощью forEach
  // foreach в качестве аргумента получает функцию-колбэк, которая запускается для каждого элемента массива
  // В качестве аргументов колбэк получает значение элемента массива, индекс элемента и ссылку на сам массив
  process.argv.slice(2).forEach(function (val, index, array) {
    if (array[index] === '--base') {
      base = array[index + 1];
    }
    if (array[index] === '--port') {
      port = array[index + 1];
    }    
  });
  createServer(base, port).start(); // Создаем и запускаем сервер
}

/**
 * Производит проверку имени директории для сервера. Возвращает в случае успеха новое имя директории, либо false
 * @param {string} base - строка с именем директории для проверки
 * @param {string} baseDef - директория сервера по умолчанию
 */
function checkBase(base, baseDef = baseDefault) {
  // Делаем блок обработки ошибок. Если произойдет ошибка чтения файлов в fs.statSync(path) это не приведет
  // к падению скрипта. Просто произойдет обработка ошибки в блоке catch
  try {
    if (base && fs.statSync(base).isDirectory()) return base;
    else throw(new Error("Invalid base directory")); // Явно создаем ошибку, чтобы попасть в catch
  } catch (error) {
    console.error("\x1b[31m%s\x1b[0m", `Invalid base directory '${base}'. Using default base directory '${baseDef}'`);
    return baseDef;
  }
}

/**
 * Производит проверку порта, в случае успеха возвращает новый номер порта, иначе возвращает порт по умолчанию
 * @param {string} portString - строка с портом для проверки
 * @param {number} portDef - порт по умолчанию
 */
function checkPort(portString, portDef = portDefault) {
  let port = parseInt(portString); // Парсим строку в число
  // Если строка не может преобразоваться в число, то parseInt возвращает NaN, который в условиях равен false
  if (port && port > 3000) return port;
  else {
    // Код "\x1b[31m%s\x1b[0m" подкрашивает наше текстовое сообщение в консоли Node в красный
    console.error("\x1b[31m%s\x1b[0m", `Invalid port ${port}. Using default port ${portDef}`);
    return portDef;
  }
}

/**
 * Создание сервера
 * @param {string} base - Имя директории для сервера
 * @param {number} port - Номер порта
 */   
function createServer(baseArg = baseDefault, portArg = portDefault) {

  // Проверяем порт и директорию сервера на корректность
  const base = checkBase(baseArg);
  const port = checkPort(portArg);
  
  // Создаем сервер, в функцию создания сервера передаем функцию-колбэк, которая каждый будет вызываться каждый раз,
  // когда происходит запрос на сервер. При каждом запросе в функцию передается два аргумента (req, res). req - это объект
  // запроса, который содержит в себе всю информацию о запросе от клиента. res - это сгенерированный объект ответа, который
  // наш сервер должен заполнить данными, чтобы потом отправить их клиенту. Затем запускаем сервер функцией listen(port),
  // которая запускает сервер на указанном в переменной port порту.
  const server = http.createServer(function(req, res) {
    // Произодим парсинг URL, по которому обратился пользователь в браузере
    let parsedURL = url.parse(req.url, true);
    // Вычисляем путь к файлу в файловой системе нашего сервера, на основе URL из запроса и значения базовой директории.
    // Вычисление происходит с помощью path.normalize(), которая генерирует путь в зависимости от ОС сервера.
    let pathname = path.normalize(base + parsedURL.pathname);
    // Отправляем запрашиваемый файл с сервера в браузер клиента
    sendFile(pathname, parsedURL.pathname, req, res);
  });

  /**
   * Класс ServerEmitter создается как наследник EventEmitter, что позволит проводить обработку событий
   * на объектах, создаваемых от класса ServerEmitter. ServerEmitter создает КАСТОМНЫЙ объект сервера, т.е.
   * объект, создаваемый от ServerEmitter будет оберткой вокруг объекта сервера, созданного выше - server.
   * С помощью событий мы сможем теперь отслеживать события не только на объекте server, но и на нашем
   * кастомном объекте, который будет создаваться от ServerEmitter (ниже по коду - serverObj)
   */
  class ServerEmitter extends EventEmitter {
    constructor(server, base, port) {
      // this это ссылка на текущий объект, т.е. объект созданный от этого класса (ниже по коду - serverObj)
      // super() вызывает конструктор родительского класса. Без этого не произойдет инициализации this
      super();
      this.server = server; // Объект сервера
      this.base = base;     // Имя папки сервера
      this.port = port;     // Номер порта
    }
    /**
     * Функция запуска сервера
     */
    start() {
      // Запускаем прослушивание сервером порта this.port. В случае ошибки (порт занят), сработает событие
      // 'error' на this.server. Ниже по коду мы будем следить за этим событием. Если 'error' не перехватить,
      // то произойдет крах всего скрипта
      this.server.listen(this.port);
      // Возвращаем кастомный объект сервера
      return this;
    }
  }

  // Создаем объект, в котором будет находиться наш сервер и его опции
  const serverObj = new ServerEmitter(server, base, port);

  // Необходимо отследить ошибку сервера, которая может произойти при вызове функции listen. Ошибка произойдет
  // если порт, на котором мы запускаем сервер занят. В этом случае запускается обработка события 'error' и 
  // связанного с ним колбэка. Внутри колбэка мы попробуем вновь запустить сервер на новом порту.
  // Обратите внимание, что обработчик события мы делаем на нашем кастомном объекте сервера. Это событие еще нужно
  // откуда-то запустить. Запуск события на кастомном сервере мы будем делать из аналогичного события на оригинальном
  // сервере. Ниже по коду это { server.on('error', e => serverObj.emit('error', e)) }
  serverObj.on('error', function(e) {
    // Проверяем, что ошибка произошла из-за того, что порт был занят
    if (e.code === 'EADDRINUSE') {
      // Сообщаем об этом:
      console.error("\x1b[31m%s\x1b[0m", `Port ${this.port} is use. Trying to use port ${this.port + 1}`);
      this.server.close();  // Закрываем текущую сессию работы сервера:
      this.port++;          // Изменяем номер порта
      this.start();         // Пробуем перезапустить сервер на повом порту
    }
  })
  // Отслеживаем событие 'started', которое сработает когда наш сервер успешно запустится
  .on('started', function() {
    console.log("\x1b[32m%s\x1b[0m", `Server running at http://localhost:${this.port} \nBase directory is ${this.base}`);
  });

  // Здесь мы вешаем обработчики событий на оригинальный сервер. Эти события запускаются в определенные моменты
  // жизни объекта сервера. В данном случае мы обрабатываем события ошибки запуска сервера и события то, что сервер
  // успешно запустился и следит за запросами пользователя. В обоих случаях мы производим запуск соответствующих
  // событий на нашем кастомном сервере. Делается это через вызов serverObj.emit функции.
  server.on('error', e => serverObj.emit('error', e))
        .on('listening', () => serverObj.emit('started'));

  // Возвращаем кастомный объект сервера
  return serverObj;
}

/**
 * Функция отправки пользователю файла с сервера. Внутри функции проверяется есть ли запрошенная сущность на диске,
 * является ли она файлом или директорией. В зависимости от этого пользователю посылаются разные ответы.
 * @param {string} pathname - имя файла в файловой системе сервера
 * @param {string} url - ссылка на файл в браузере пользователя
 * @param {IncomingMessage} req - объект запроса пользователя
 * @param {ServerResponse} res - объект ответа сервера
 */
function sendFile(pathname, url, req, res) {
  // Получаем информацию о запрашиваемом файле. Вторым параметром передаем колбэк, в котором обрабатываем файл.
  fs.stat(pathname, function(err, stats) {
    // Если объект ошибки не пустой (т.е. произошла ошибка чтения файла), то в ответ сервера пишем сообщение об ошибке
    if (err) {
      res.writeHead(404); // Записываем в заголовок ответа код ответа 404
      console.error("\x1b[31m%s\x1b[0m", 'Resource missing 404: ' + pathname);
      res.write('Resource missing 404'); // Записываем в ответ сообщение
      res.end(); // Закрываем соединение
    } else if (stats.isFile()) {
      // Если файл является файлом, то создаем и перенаправляем поток для чтения
      createStream(pathname, res);
    } else if (req.headers['x-requested-with'] === undefined) {
      // Иначе считаем, что запрашиваемый файл является папкой (например, когда обращаемся к корню сайта), и затем проверяем, 
      // что к серверу не происходит AJAX запрос. Далее делаем переадресацию на index.html в этой папке с помощью установки 
      // заголовка ответа 'Location' и кода ответа 301. С указанными заголовками браузер должен перейти на index.html
      res.setHeader('Location', path.normalize(url + '/index.html'));
      res.statusCode = 301;
      res.end();
    }
  })
}

/**
 * Функция создания потока данных из файла. Созданный поток данных проходит gzip сжатие и передается напрямую клиенту
 * @param {string} pathname - имя файла в файловой системе сервера
 * @param {ServerResponse} res  - объект ответа сервера
 */
function createStream(pathname, res) {
  // Создаем из файла поток данных
  let file = fs.createReadStream(pathname);
  // Отслеживаем событие открытия потока данных "open". Как только открытие произошло запускается функция-колбэк
  file.on("open", function() {    
    const gzip = zlib.createGzip(); // Создаем поток для сжатия данных    
    const type = mime.lookup(pathname); // Определяем mime-тип файла
    console.log("\x1b[32m%s\x1b[0m", "GET file: " + pathname); // Подкрашиваем вывод в зеленый цвет
    // Устанавливаем заголовок 'Content-Type' с правильным mime-типом для отправляемого с сервера файла. Без этого
    // mime-типа файлы могут быть неправильно обработаны браузером
    res.setHeader('Content-Type', `${type}; charset=utf-8`);
    // Заголовком 'Content-Encoding' мы указываем браузеру, что для сжатия используется 'gzip'
    res.setHeader('Content-Encoding', 'gzip');    
    res.statusCode = 200; // Код 200 - файл найден, ошибок нет
    // Инициализируем передачу потока сначала из потока файла в поток сжатия, а затем из потока сжатия в поток ответа сервера
    file.pipe(gzip).pipe(res);
  });
  // В случае события ошибки создания потока из файла запускаем следующий колбэк
  file.on("error", function(err) {
    console.error("\x1b[31m%s\x1b[0m", err);
    res.statusCode = 403;
    res.write('file permission');
    res.end();
  });
}

// Делаем экспорт в формате require.js, чтобы модуль сервера можно было бы импортировать и использовать в других
// Node приложениях. В частности, мы будем использовать модуль сервера в скрипте сборки проекта gulpfile.js
module.exports = {
  createServer: createServer
}